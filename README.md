ë„¤, ìš”ì²­í•˜ì‹  ëŒ€ë¡œ Raylib ì¥ì• ë¬¼ í”¼í•˜ê¸° ê²Œì„ì˜ ëª¨ë“  ê¸°ëŠ¥ ì„¤ëª…ê³¼ í•´ë‹¹ ì½”ë“œ ìŠ¤ë‹ˆí«ì„ í•˜ë‚˜ì˜ ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œ ì•ˆì— ëª…í™•í•˜ê²Œ ì •ë¦¬í•˜ì—¬ ë³´ì—¬ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

````markdown
# ğŸ® Raylib ì¥ì• ë¬¼ í”¼í•˜ê¸° ê²Œì„

## ğŸ“Œ í”„ë¡œì íŠ¸ ê°œìš”
- **íŒ€ëª…**: 9íŒ€
- **íŒ€ì›**: ì „ì¬ë¯¼(íŒ€ì¥), ê¹€ì¤€ìš©, ê¹€ë¬´ì§„
- **ê°œë°œ ê¸°ê°„**: 2025ë…„ 05ì›” 14ì¼ ~ 2025ë…„ 05ì›” 18ì¼ (ì´ 5ì¼)
- **ì£¼ìš” ê¸°ìˆ **: C++, raylib ë¼ì´ë¸ŒëŸ¬ë¦¬, ê²Œì„ ë£¨í”„, ì¶©ëŒ ê°ì§€, ê°ì²´ ê´€ë¦¬ ë“±

## ğŸ‘¥ íŒ€ì› ì—­í•  ë¶„ë‹´

| ì´ë¦„ | ì—­í•  | ì£¼ìš” ë‹´ë‹¹ ì—…ë¬´ |
|------|------|----------------|
| ì „ì¬ë¯¼ | í”„ë¡œì íŠ¸ ê´€ë¦¬ / ê¸°íš ë° ì„¤ê³„ | ì „ì²´ ê²Œì„ êµ¬ì¡° ì„¤ê³„, í•µì‹¬ ê¸°ëŠ¥ ì •ì˜, ê°œë°œ ë°©í–¥ ì œì‹œ, Git ê´€ë¦¬ |
| ê¹€ë¬´ì§„ | ê°œë°œ | ê²Œì„ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„ (ì£¼ì¸ê³µ, ì¥ì• ë¬¼, ì¶©ëŒ, ì ìˆ˜), ì†ë„/í¬ê¸° ë³€í™” ë¡œì§ ì½”ë”©, raylib ê¸°ëŠ¥ í™œìš© |
| ê¹€ì¤€ìš© | ë¬¸ì„œ / í…ŒìŠ¤íŠ¸ | í”„ë¡œì íŠ¸ ë³´ê³ ì„œ ì‘ì„±, README ë¬¸ì„œ ê´€ë¦¬, í…ŒìŠ¤íŠ¸ ê³„íš ìˆ˜ë¦½ ë° ì‹¤í–‰, ë²„ê·¸ ë¦¬í¬íŒ… |

## ğŸ® ê²Œì„ ì„¤ëª…

* **ì¡°ì‘:** ì¢Œìš° ë°©í–¥í‚¤ë¡œ íŒŒë€ìƒ‰ í”Œë ˆì´ì–´ ë°”ë¥¼ ì¡°ì‘í•©ë‹ˆë‹¤.
* **ëª©í‘œ:** ìœ„ì—ì„œ ë–¨ì–´ì§€ëŠ” ë¹¨ê°„ìƒ‰ ì¥ì• ë¬¼ì„ í”¼í•˜ê³ , ì´ˆë¡ìƒ‰ ìƒëª… ë°•ìŠ¤ë¥¼ íšë“í•˜ì—¬ ìƒëª…ì„ ìœ ì§€í•˜ë©° ìµœëŒ€í•œ ì˜¤ë˜ ë²„íŒë‹ˆë‹¤.
* **ìƒëª…:** ê²Œì„ ì‹œì‘ ì‹œ 3ê°œì˜ ìƒëª…ì„ ê°€ì§‘ë‹ˆë‹¤.
* **ì¥ì• ë¬¼ (ë¹¨ê°„ìƒ‰ ë°•ìŠ¤):** ë‹¿ìœ¼ë©´ ìƒëª…ì´ 1 ê°ì†Œí•©ë‹ˆë‹¤.
* **ìƒëª… ë°•ìŠ¤ (ì´ˆë¡ìƒ‰ ë°•ìŠ¤):** íšë“í•˜ë©´ ìƒëª…ì´ 1 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ ìƒëª… ì œí•œ ìˆìŒ).
* **ê²Œì„ ì˜¤ë²„:** ìƒëª…ì´ 0ì´ ë˜ë©´ ê²Œì„ì´ ì¢…ë£Œë˜ê³  ê²Œì„ ì˜¤ë²„ í™”ë©´ì´ í‘œì‹œë©ë‹ˆë‹¤.
* **ì ìˆ˜:** ì¼ì • ì‹œê°„ë§ˆë‹¤ ì ìˆ˜ë¥¼ íšë“í•˜ë©°, ì¥ì• ë¬¼ì„ í”¼í•˜ê±°ë‚˜ ìƒëª… ë°•ìŠ¤ë¥¼ íšë“í•˜ëŠ” ê²ƒìœ¼ë¡œëŠ” ì§ì ‘ì ì¸ ì ìˆ˜ë¥¼ ì–»ì§€ ì•ŠìŠµë‹ˆë‹¤.
* **ìŠ¤í…Œì´ì§€:** ì¼ì • ì ìˆ˜ë§ˆë‹¤ ìŠ¤í…Œì´ì§€ê°€ ì¦ê°€í•˜ë©°, ìŠ¤í…Œì´ì§€ì— ë”°ë¼ ê²Œì„ ë‚œì´ë„ê°€ ìƒìŠ¹í•©ë‹ˆë‹¤.

## âœ¨ ì£¼ìš” ê¸°ëŠ¥

1.  **í”Œë ˆì´ì–´ ì¡°ì‘:** ì¢Œìš° ë°©í–¥í‚¤ë¥¼ ì‚¬ìš©í•œ í”Œë ˆì´ì–´ ì´ë™ ë° í™”ë©´ ê²½ê³„ ì œí•œ.
2.  **ì¥ì• ë¬¼/ì•„ì´í…œ ê´€ë¦¬:** í™”ë©´ ìƒë‹¨ì—ì„œ ìƒì„±ë˜ì–´ í•˜ë‹¨ìœ¼ë¡œ ì´ë™í•˜ëŠ” ì¥ì• ë¬¼(ë¹¨ê°„ìƒ‰) ë° ìƒëª… íšŒë³µ ì•„ì´í…œ(ì´ˆë¡ìƒ‰) ìƒì„±, ì´ë™, í™”ë©´ ë°– ì œê±°.
3.  **ì¶©ëŒ ê°ì§€:** í”Œë ˆì´ì–´ì™€ ì¥ì• ë¬¼/ì•„ì´í…œ ê°„ì˜ ì¶©ëŒ ê°ì§€ ë° ìƒëª… ì¦ê° ì²˜ë¦¬.
4.  **ìƒëª… ì‹œìŠ¤í…œ:** ì´ˆê¸° ìƒëª… ì„¤ì •, ìƒëª… ê°ì†Œ ë° ì¦ê°€, ê²Œì„ ì˜¤ë²„ ë¡œì§.
5.  **ì ìˆ˜ ì‹œìŠ¤í…œ:** ì‹œê°„ ê²½ê³¼ì— ë”°ë¥¸ ì ìˆ˜ íšë“ ë° ì´ ì ìˆ˜ í‘œì‹œ.
6.  **ì‹œê°„ í‘œì‹œ:** í˜„ì¬ ê²½ê³¼ ì‹œê°„ì„ ì´ˆ ë‹¨ìœ„ë¡œ í‘œì‹œ.
7.  **ìŠ¤í…Œì´ì§€ ì‹œìŠ¤í…œ:** ì ìˆ˜ì— ë”°ë¥¸ ìŠ¤í…Œì´ì§€ ì¦ê°€, ì¥ì• ë¬¼ ë‚™í•˜ ì†ë„ ë° ìƒì„± ë¹ˆë„ ì¦ê°€ë¥¼ í†µí•œ ë‚œì´ë„ ì¡°ì ˆ.
8.  **ê²Œì„ ìƒíƒœ ê´€ë¦¬:** ê²Œì„ í”Œë ˆì´, ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì „í™˜ ë° ê° ìƒíƒœì— ë§ëŠ” ì²˜ë¦¬.
9.  **UI:** ê²Œì„ ì¤‘ ìƒëª…/ì ìˆ˜/ì‹œê°„/ìŠ¤í…Œì´ì§€ í‘œì‹œ, ê²Œì„ ì˜¤ë²„ í™”ë©´ ì¶œë ¥.
10. **ì¬ì‹œì‘/ì¢…ë£Œ:** ê²Œì„ ì˜¤ë²„ ì‹œ Space í‚¤ë¡œ ì¬ì‹œì‘, ëª¨ë“  ìƒíƒœì—ì„œ Esc í‚¤ë¡œ ì¢…ë£Œ.

## ğŸ› ï¸ êµ¬í˜„ êµ¬ì¡° ë° ì½”ë“œ ìŠ¤ë‹ˆí« (ì˜ˆì‹œ)

ì´ ê²Œì„ì€ Raylibì˜ ë©”ì¸ ë£¨í”„ êµ¬ì¡°ë¥¼ ë”°ë¥´ë©°, `GameManager` í´ë˜ìŠ¤ ë“±ì„ í™œìš©í•˜ì—¬ ê²Œì„ ìƒíƒœ ë° ê°ì²´ë“¤ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.

### 1. ê²Œì„ ì´ˆê¸°í™” ë° ë©”ì¸ ë£¨í”„ êµ¬ì„±

Raylib ì°½ì„ ìƒì„±í•˜ê³  ê²Œì„ì˜ ê¸°ë³¸ ìƒíƒœë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. `InitGame()`, `UpdateGame()`, `DrawGame()` í•¨ìˆ˜ë¥¼ ê²Œì„ ë£¨í”„ ë‚´ì—ì„œ í˜¸ì¶œí•˜ì—¬ ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸ ë° í™”ë©´ ê·¸ë¦¬ê¸°ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```cpp
// ì˜ˆì‹œ: main í•¨ìˆ˜ ì¼ë¶€
#include "raylib.h" // raylib í—¤ë” í¬í•¨
#include <vector>   // std::vector ì‚¬ìš©
#include <string>   // TextFormat ë“± ì‚¬ìš©
#include <algorithm> // std::remove_if ì‚¬ìš©

// ê²Œì„ ìƒíƒœ ì—´ê±°í˜• (GameManager í´ë˜ìŠ¤ ë‚´ì— ì •ì˜ë  ìˆ˜ ìˆìŒ)
enum GameState {
    GAME_PLAYING,
    GAME_OVER
};

// ì„ì‹œ Player, Obstacle, LifeItem êµ¬ì¡°ì²´/í´ë˜ìŠ¤ ì„ ì–¸ (ì‹¤ì œ êµ¬í˜„ì€ ë” ë³µì¡í•  ìˆ˜ ìˆìŒ)
struct Player {
    Vector2 position = { 0, 0 };
    Vector2 size = { 0, 0 };
    Color color = BLUE;
    float speed = 300.0f; // ì´ë™ ì†ë„
    int lives = 3;
    int maxLives = 5; // ìµœëŒ€ ìƒëª…
    // TODO: ë¬´ì  ì‹œê°„ ê´€ë ¨ ë©¤ë²„ ì¶”ê°€ ê°€ëŠ¥
    void Update(float deltaTime, int screenWidth, int screenHeight);
    void Draw();
    // void HandleInput(); // GameManagerì—ì„œ ì²˜ë¦¬í•˜ê±°ë‚˜ Player ë‚´ë¶€ì—ì„œ ì²˜ë¦¬
};

struct Obstacle {
    Vector2 position = { 0, 0 };
    Vector2 size = { 0, 0 };
    Color color = RED;
    float speed = 200.0f; // ë‚™í•˜ ì†ë„
    void Update(float deltaTime);
    void Draw();
    bool IsOffScreen(int screenHeight);
};

struct LifeItem {
    Vector2 position = { 0, 0 };
    Vector2 size = { 0, 0 };
    Color color = GREEN;
    float speed = 150.0f; // ë‚™í•˜ ì†ë„ (ì¥ì• ë¬¼ë³´ë‹¤ ì•½ê°„ ëŠë¦¬ê²Œ)
    void Update(float deltaTime);
    void Draw();
    bool IsOffScreen(int screenHeight);
};

// ì„ì‹œ GameManager í´ë˜ìŠ¤ ì„ ì–¸
class GameManager {
public:
    GameState gameState = GAME_PLAYING;
    Player player;
    std::vector<Obstacle> obstacles;
    std::vector<LifeItem> lifeItems;

    int screenWidth;
    int screenHeight;

    int score = 0;
    int finalScore = 0; // ê²Œì„ ì˜¤ë²„ ì‹œ ìµœì¢… ì ìˆ˜
    float elapsedTime = 0.0f;
    float lastScoreTime = 0.0f; // ë§ˆì§€ë§‰ìœ¼ë¡œ ì ìˆ˜ íšë“í•œ ì‹œê°„

    int currentStage = 1;
    int scorePerStage = 10; // ìŠ¤í…Œì´ì§€ ì¦ê°€ì— í•„ìš”í•œ ì ìˆ˜ ê¸°ì¤€

    float baseObstacleSpeed = 200.0f; // ê¸°ë³¸ ì¥ì• ë¬¼ ì†ë„
    float speedIncreasePerStage = 50.0f; // ìŠ¤í…Œì´ì§€ë‹¹ ì¦ê°€ ì†ë„
    float baseSpawnRate = 2.0f; // ê¸°ë³¸ ìƒì„± ê°„ê²© (ì´ˆ)
    float spawnRateDecreasePerStage = 0.2f; // ìŠ¤í…Œì´ì§€ë‹¹ ìƒì„± ê°„ê²© ê°ì†ŒëŸ‰

    float timeSinceLastObstacle = 0.0f; // ë§ˆì§€ë§‰ ì¥ì• ë¬¼ ìƒì„± í›„ ê²½ê³¼ ì‹œê°„
    float timeSinceLastLifeItem = 0.0f; // ë§ˆì§€ë§‰ ìƒëª… ì•„ì´í…œ ìƒì„± í›„ ê²½ê³¼ ì‹œê°„
    float lifeItemSpawnRate = 10.0f; // ìƒëª… ì•„ì´í…œ ìƒì„± ê°„ê²© (ì´ˆ)

    bool shouldClose = false; // ê²Œì„ ì¢…ë£Œ í”Œë˜ê·¸

    GameManager() {}

    void InitGame(int width, int height) {
        screenWidth = width;
        screenHeight = height;

        gameState = GAME_PLAYING;
        score = 0;
        finalScore = 0;
        elapsedTime = 0.0f;
        lastScoreTime = 0.0f;
        currentStage = 1;
        timeSinceLastObstacle = 0.0f;
        timeSinceLastLifeItem = 0.0f;

        // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
        player.size = { 80, 20 };
        player.position = { (float)screenWidth / 2 - player.size.x / 2, (float)screenHeight - player.size.y - 10 };
        player.lives = 3;
        player.maxLives = 5;
        player.speed = 300.0f;

        // ì¥ì• ë¬¼ ë° ì•„ì´í…œ ëª©ë¡ ì´ˆê¸°í™”
        obstacles.clear();
        lifeItems.clear();

        shouldClose = false;
    }

    void HandleInput() {
        // Esc í‚¤ëŠ” ì–´ë–¤ ìƒíƒœì—ì„œë“  ê²Œì„ ì¢…ë£Œ
        if (IsKeyPressed(KEY_ESCAPE)) {
            shouldClose = true;
        }

        if (gameState == GAME_PLAYING) {
            // í”Œë ˆì´ ì¤‘ ìƒíƒœì—ì„œì˜ ì…ë ¥ (í”Œë ˆì´ì–´ ì´ë™)
            // í”Œë ˆì´ì–´ í´ë˜ìŠ¤ì˜ HandleInput í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ì§ì ‘ ì²˜ë¦¬
            if (IsKeyDown(KEY_RIGHT)) player.position.x += player.speed * GetFrameTime();
            if (IsKeyDown(KEY_LEFT)) player.position.x -= player.speed * GetFrameTime();

            // í™”ë©´ ê²½ê³„ ì²´í¬ (Updateì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ì§€ë§Œ ì…ë ¥ê³¼ í•¨ê»˜ ì²˜ë¦¬ ê°€ëŠ¥)
            if (player.position.x < 0) player.position.x = 0;
            if (player.position.x > screenWidth - player.size.x) player.position.x = screenWidth - player.size.x;

        } else if (gameState == GAME_OVER) {
            // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œì˜ ì…ë ¥ (ì¬ì‹œì‘)
            if (IsKeyPressed(KEY_SPACE)) {
                InitGame(screenWidth, screenHeight); // ê²Œì„ ì¬ì‹œì‘
            }
        }
    }

    void UpdateGame(float deltaTime) {
        if (gameState == GAME_PLAYING) {
            elapsedTime += deltaTime; // ê²½ê³¼ ì‹œê°„ ëˆ„ì 

            // 1ì´ˆë§ˆë‹¤ ì ìˆ˜ íšë“
            if (elapsedTime - lastScoreTime >= 1.0f) { // 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì²´í¬
                score++;
                lastScoreTime = elapsedTime; // ë§ˆì§€ë§‰ ì ìˆ˜ íšë“ ì‹œê°„ ì—…ë°ì´íŠ¸

                // ìŠ¤í…Œì´ì§€ ì¦ê°€ ì¡°ê±´ ì²´í¬ ë° ì²˜ë¦¬
                CheckStageIncrease();
            }

            // í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸ (ê²½ê³„ ì²´í¬ ë“±)
            player.Update(deltaTime, screenWidth, screenHeight);

            // ì¥ì• ë¬¼ ìƒì„±
            timeSinceLastObstacle += deltaTime;
            // í˜„ì¬ ìŠ¤í…Œì´ì§€ì— ë§ëŠ” ìƒì„± ê°„ê²© ê³„ì‚°
            float currentSpawnRate = baseSpawnRate - (currentStage - 1) * spawnRateDecreasePerStage;
            if (currentSpawnRate < 0.5f) currentSpawnRate = 0.5f; // ìµœì†Œ ì œí•œ

            if (timeSinceLastObstacle >= currentSpawnRate) {
                Obstacle newObstacle;
                newObstacle.size = { 30, 30 }; // ì˜ˆì‹œ í¬ê¸°
                newObstacle.position = { (float)GetRandomValue(0, screenWidth - (int)newObstacle.size.x), -newObstacle.size.y }; // í™”ë©´ ìƒë‹¨ ì„ì˜ ìœ„ì¹˜
                newObstacle.speed = baseObstacleSpeed + (currentStage - 1) * speedIncreasePerStage; // í˜„ì¬ ìŠ¤í…Œì´ì§€ ì†ë„ ì ìš©
                obstacles.push_back(newObstacle);
                timeSinceLastObstacle = 0.0f; // íƒ€ì´ë¨¸ ë¦¬ì…‹
            }

            // ìƒëª… ì•„ì´í…œ ìƒì„±
            timeSinceLastLifeItem += deltaTime;
             if (timeSinceLastLifeItem >= lifeItemSpawnRate) {
                LifeItem newLifeItem;
                newLifeItem.size = { 25, 25 }; // ì˜ˆì‹œ í¬ê¸°
                newLifeItem.position = { (float)GetRandomValue(0, screenWidth - (int)newLifeItem.size.x), -newLifeItem.size.y }; // í™”ë©´ ìƒë‹¨ ì„ì˜ ìœ„ì¹˜
                newLifeItem.speed = player.speed * 0.5f; // í”Œë ˆì´ì–´ ì†ë„ì˜ ì ˆë°˜ (ì˜ˆì‹œ)
                lifeItems.push_back(newLifeItem);
                timeSinceLastLifeItem = 0.0f; // íƒ€ì´ë¨¸ ë¦¬ì…‹
            }


            // ì¥ì• ë¬¼ ì—…ë°ì´íŠ¸ ë° í™”ë©´ ë°– ì œê±°
            for (auto& obs : obstacles) {
                obs.Update(deltaTime);
            }
            obstacles.erase(std::remove_if(obstacles.begin(), obstacles.end(), [&](const Obstacle& o){
                return o.IsOffScreen(screenHeight);
            }), obstacles.end());

            // ìƒëª… ì•„ì´í…œ ì—…ë°ì´íŠ¸ ë° í™”ë©´ ë°– ì œê±°
             for (auto& item : lifeItems) {
                item.Update(deltaTime);
            }
            lifeItems.erase(std::remove_if(lifeItems.begin(), lifeItems.end(), [&](const LifeItem& i){
                return i.IsOffScreen(screenHeight);
            }), lifeItems.end());


            // ì¶©ëŒ ì²´í¬
            CheckCollisions();

            // ê²Œì„ ì˜¤ë²„ ì¡°ê±´ ì²´í¬ëŠ” CheckCollisionsì—ì„œ ìˆ˜í–‰ë¨

        } else if (gameState == GAME_OVER) {
            // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” ì—…ë°ì´íŠ¸í•  ë‚´ìš© ì—†ìŒ (ì…ë ¥ë§Œ ì²˜ë¦¬)
        }
    }

    void DrawGame() {
        BeginDrawing();
        ClearBackground(RAYWHITE);

        if (gameState == GAME_PLAYING) {
            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            player.Draw();

            // ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
            for (const auto& obs : obstacles) {
                obs.Draw();
            }

            // ìƒëª… ì•„ì´í…œ ê·¸ë¦¬ê¸°
             for (const auto& item : lifeItems) {
                item.Draw();
            }

            // UI í‘œì‹œ (ì ìˆ˜, ìƒëª…, ì‹œê°„, ìŠ¤í…Œì´ì§€)
            DrawText(TextFormat("Score: %i", score), 10, 10, 20, BLACK);
            DrawText(TextFormat("Lives: %i", player.lives), 10, 30, 20, BLACK);
            DrawText(TextFormat("Time: %.0f", elapsedTime), 10, 50, 20, BLACK); // ì´ˆ ë‹¨ìœ„ ì •ìˆ˜ë¡œ í‘œì‹œ
            DrawText(TextFormat("Stage: %i", currentStage), screenWidth - 100, 10, 20, BLACK);

        } else if (gameState == GAME_OVER) {
            const char* gameOverText = "Game Over!";
            DrawText(gameOverText, screenWidth/2 - MeasureText(gameOverText, 40)/2, screenHeight/2 - 40, 40, RED); // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì¡°ì •
            DrawText(TextFormat("Final Score: %i", finalScore), screenWidth/2 - MeasureText(TextFormat("Final Score: %i", finalScore), 30)/2, screenHeight/2 + 0, 30, BLACK); // í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì •
            DrawText("Press SPACE to Restart", screenWidth/2 - MeasureText("Press SPACE to Restart", 20)/2, screenHeight/2 + 40, 20, DARKGRAY);
            DrawText("Press ESC to Exit", screenWidth/2 - MeasureText("Press ESC to Exit", 20)/2, screenHeight/2 + 60, 20, DARKGRAY);
        }

        EndDrawing();
    }

    void CheckCollisions() {
        // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” ì¶©ëŒ ì²´í¬ë¥¼ í•˜ì§€ ì•ŠìŒ
        if (gameState != GAME_PLAYING) return;

        // ì£¼ì¸ê³µì˜ ì¶©ëŒ ì˜ì—­ (ì‚¬ê°í˜•)
        Rectangle playerRect = { player.position.x, player.position.y, player.size.x, player.size.y };

        // --- ì¥ì• ë¬¼ê³¼ì˜ ì¶©ëŒ ì²´í¬ (ìƒëª… ê°ì†Œ) ---
        // ì¥ì• ë¬¼ ëª©ë¡ì„ ìˆœíšŒí•˜ë©° ì¶©ëŒ ì²´í¬ ë° ì œê±°
        obstacles.erase(std::remove_if(obstacles.begin(), obstacles.end(), [&](const Obstacle& obs){
            Rectangle obstacleRect = { obs.position.x, obs.position.y, obs.size.x, obs.size.y };
            bool collided = CheckCollisionRecs(playerRect, obstacleRect);

            if (collided) {
                // TODO: í”Œë ˆì´ì–´ ë¬´ì  ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ìƒëª… ê°ì†Œ
                // if (!player.isInvincible) {
                    player.lives--; // Player í´ë˜ìŠ¤ì— lives ë©¤ë²„ê°€ ìˆë‹¤ê³  ê°€ì •
                    TraceLog(LOG_INFO, TextFormat("Hit Obstacle! Lives: %i", player.lives));
                    // TODO: í”Œë ˆì´ì–´ì—ê²Œ ì§§ì€ ë¬´ì  ì‹œê°„ ë¶€ì—¬ (ë¬´ì  íƒ€ì´ë¨¸ ì‹œì‘ ë“±)
                    return true; // ì¶©ëŒí•œ ì¥ì• ë¬¼ ì œê±°
                // }
            }
            return obs.IsOffScreen(screenHeight); // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì¥ì• ë¬¼ ì œê±°
        }), obstacles.end());


        // --- ìƒëª… íšŒë³µ ì•„ì´í…œê³¼ì˜ ì¶©ëŒ ì²´í¬ (ìƒëª… ì¦ê°€) ---
        // ìƒëª… íšŒë³µ ì•„ì´í…œ ëª©ë¡ì„ ìˆœíšŒí•˜ë©° ì¶©ëŒ ì²´í¬ ë° ì œê±°
        lifeItems.erase(std::remove_if(lifeItems.begin(), lifeItems.end(), [&](const LifeItem& item){
             Rectangle lifeItemRect = { item.position.x, item.position.y, item.size.x, item.size.y };
             bool collided = CheckCollisionRecs(playerRect, lifeItemRect);

            if (collided) {
                // ì¶©ëŒ ë°œìƒ ì‹œ ìƒëª… ì¦ê°€ (ìµœëŒ€ ìƒëª… ì œí•œ)
                player.lives++; // ìƒëª… ì¦ê°€
                 if (player.lives > player.maxLives) {
                    player.lives = player.maxLives; // ìµœëŒ€ ìƒëª…ìœ¼ë¡œ ì œí•œ
                }
                TraceLog(LOG_INFO, TextFormat("Got Life Item! Lives: %i", player.lives));
                return true; // ì¶©ëŒí•œ ì•„ì´í…œ ì œê±°
            }
            return item.IsOffScreen(screenHeight); // í™”ë©´ ë°– ì•„ì´í…œ ì œê±°
        }), lifeItems.end());

        // ëª¨ë“  ì¶©ëŒ ì²´í¬ ë° ìƒëª… ìƒíƒœ í™•ì¸ í›„ ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì „í™˜
        if (player.lives <= 0) {
            gameState = GAME_OVER;
            finalScore = score; // ê²Œì„ ì˜¤ë²„ ì‹œ ìµœì¢… ì ìˆ˜ ì €ì¥
            TraceLog(LOG_INFO, TextFormat("Game Over! Final Score: %i", finalScore));
            // TODO: ê²Œì„ ì˜¤ë²„ ìƒíƒœë¡œ ì „í™˜ ì‹œ í•„ìš”í•œ ì¶”ê°€ ì‘ì—… (ì˜ˆ: íƒ€ì´ë¨¸ ì¤‘ì§€)
        }
    }

    void CheckStageIncrease() {
        // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì— í•„ìš”í•œ ì ìˆ˜ ê³„ì‚°
        int requiredScoreForNextStage = currentStage * scorePerStage;

        if (score >= requiredScoreForNextStage) {
            currentStage++;
            TraceLog(LOG_INFO, TextFormat("Stage Increased! Current Stage: %i", currentStage));

            // TODO: ìŠ¤í…Œì´ì§€ ì¦ê°€ì— ë”°ë¥¸ ì†ë„/í¬ê¸° ë³€í™” ì ìš© (ì¥ì• ë¬¼ ìƒì„± ì‹œ ë°˜ì˜í•˜ê±°ë‚˜ í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¥ì• ë¬¼ ì—…ë°ì´íŠ¸)
            // í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¥ì• ë¬¼ë“¤ì˜ ì†ë„ ì—…ë°ì´íŠ¸ (ì˜ˆì‹œ)
            float newObstacleSpeed = baseObstacleSpeed + (currentStage - 1) * speedIncreasePerStage;
             for (auto& obs : obstacles) { obs.speed = newObstacleSpeed; }

            // ìŠ¤í…Œì´ì§€ ì¦ê°€ì— ë”°ë¥¸ ìƒì„± ë¹ˆë„ ì¦ê°€ (ìƒì„± ê°„ê²© ê°ì†Œ)ëŠ” UpdateGameì—ì„œ timeSinceLastObstacle ë¡œì§ì— ì˜í•´ ìë™ ì ìš©ë¨
        }
    }

    bool ShouldClose() const { return shouldClose || WindowShouldClose(); }
};

// ì„ì‹œ Player, Obstacle, LifeItem í•¨ìˆ˜ ì •ì˜ (ê°„ë‹¨í•œ êµ¬í˜„)
void Player::Update(float deltaTime, int screenWidth, int screenHeight) {
    // ì…ë ¥ ì²˜ë¦¬ëŠ” GameManager::HandleInputì—ì„œ ì´ë¯¸ ìˆ˜í–‰ëœë‹¤ê³  ê°€ì •í•˜ê±°ë‚˜,
    // Player::HandleInput() í•¨ìˆ˜ë¥¼ ë³„ë„ë¡œ í˜¸ì¶œí•˜ì—¬ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    // í™”ë©´ ê²½ê³„ ì²´í¬
    if (position.x < 0) position.x = 0;
    if (position.x > screenWidth - size.x) position.x = screenWidth - size.x;
    // TODO: ë¬´ì  ì‹œê°„ ì—…ë°ì´íŠ¸ ë¡œì§ ì¶”ê°€
}

void Player::Draw() {
    DrawRectangleV(position, size, color);
    // TODO: ìƒëª… í‘œì‹œ ë“±ì„ Player í´ë˜ìŠ¤ ë‚´ë¶€ ë˜ëŠ” GameManagerì—ì„œ ì²˜ë¦¬
}

void Obstacle::Update(float deltaTime) {
    position.y += speed * deltaTime;
}

void Obstacle::Draw() {
    DrawRectangleV(position, size, color);
}

bool Obstacle::IsOffScreen(int screenHeight) {
    return position.y > screenHeight;
}

void LifeItem::Update(float deltaTime) {
    position.y += speed * deltaTime;
}

void LifeItem::Draw() {
    DrawRectangleV(position, size, color);
}

bool LifeItem::IsOffScreen(int screenHeight) {
    return position.y > screenHeight;
}


// main í•¨ìˆ˜ êµ¬í˜„
int main() {
    const int screenWidth = 800;
    const int screenHeight = 450;

    InitWindow(screenWidth, screenHeight, "Raylib Avoid Game");
    SetTargetFPS(60); // í”„ë ˆì„ ì†ë„ ì„¤ì •

    GameManager game;
    game.InitGame(screenWidth, screenHeight); // ê²Œì„ ì´ˆê¸°í™”

    while (!game.ShouldClose()) { // Esc í‚¤ ë˜ëŠ” ì°½ ë‹«ê¸° ë²„íŠ¼ í´ë¦­ ì‹œ ì¢…ë£Œ
        game.HandleInput();              // ì…ë ¥ ì²˜ë¦¬
        game.UpdateGame(GetFrameTime()); // ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
        game.DrawGame();                 // ê²Œì„ í™”ë©´ ê·¸ë¦¬ê¸°
    }

    CloseWindow(); // ì°½ ë‹«ê¸°
    return 0;
}

````

ìœ„ ì½”ë“œëŠ” ê²Œì„ì˜ í•µì‹¬ êµ¬ì¡°ì™€ ê¸°ëŠ¥ì„ ë³´ì—¬ì£¼ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤. ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œëŠ” ê° í´ë˜ìŠ¤(Player, Obstacle, LifeItem, GameManager)ë¥¼ ë³„ë„ì˜ í—¤ë” íŒŒì¼(`.h`) ë° ì†ŒìŠ¤ íŒŒì¼(`.cpp`)ë¡œ ë¶„ë¦¬í•˜ì—¬ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤. ë˜í•œ, Raylib ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ `#include "raylib.h"`ê°€ í•„ìš”í•˜ë©°, `GetFrameTime()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ í”„ë ˆì„ ê°„ ê²½ê³¼ ì‹œê°„ì„ ì–»ì–´ ê°ì²´ ì´ë™ ë° íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸ì— ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

### 2\. ì£¼ì¸ê³µ ì´ë™ êµ¬í˜„

`Player` í´ë˜ìŠ¤ì˜ `Update` í•¨ìˆ˜ì—ì„œ ì¢Œìš° ë°©í–¥í‚¤ ì…ë ¥ì„ ë°›ì•„ `position.x` ê°’ì„ ë³€ê²½í•˜ê³ , í™”ë©´ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ì œí•œí•©ë‹ˆë‹¤.

```cpp
// Player í´ë˜ìŠ¤ Update í•¨ìˆ˜ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void Player::Update(float deltaTime, int screenWidth, int screenHeight) {
    // ì¢Œìš° í™”ì‚´í‘œ í‚¤ ì…ë ¥ì— ë”°ë¥¸ ìˆ˜í‰ ìœ„ì¹˜ ë³€ê²½ì€ GameManager::HandleInputì—ì„œ ì²˜ë¦¬í•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ì²˜ë¦¬
    // if (IsKeyDown(KEY_RIGHT)) position.x += speed * deltaTime;
    // if (IsKeyDown(KEY_LEFT))  position.x -= speed * deltaTime;

    // í™”ë©´ ì¢Œìš° ê²½ê³„ ì²´í¬
    if (position.x < 0) position.x = 0;
    if (position.x > screenWidth - size.x) position.x = screenWidth - size.x;

    // TODO: ë¬´ì  ì‹œê°„ ì²˜ë¦¬ ë¡œì§ ì¶”ê°€ë  ìˆ˜ ìˆìŒ (íƒ€ì´ë¨¸ ê°ì†Œ ë“±)
}

// Player í´ë˜ìŠ¤ Draw í•¨ìˆ˜ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void Player::Draw() {
    DrawRectangleV(position, size, color);
    // TODO: ìƒëª… í‘œì‹œ ë“±ì„ í”Œë ˆì´ì–´ í´ë˜ìŠ¤ ë‚´ë¶€ ë˜ëŠ” GameManagerì—ì„œ ì²˜ë¦¬ (í˜„ì¬ëŠ” GameManagerì—ì„œ ì²˜ë¦¬)
}
```

### 3\. ì¥ì• ë¬¼ ë° ìƒëª… ë°•ìŠ¤ ìƒì„± ë° ì´ë™

`Obstacle` ë° `LifeItem` í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ê³ , `GameManager::UpdateGame` í•¨ìˆ˜ ë‚´ì—ì„œ ì¼ì • ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ ëª©ë¡ì— ì¶”ê°€í•©ë‹ˆë‹¤. ê° ê°ì²´ì˜ `Update` í•¨ìˆ˜ì—ì„œ `position.y` ê°’ì„ ì¦ê°€ì‹œì¼œ í•˜ë‹¨ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³ , `IsOffScreen` í•¨ìˆ˜ë¥¼ í†µí•´ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ê°ì²´ë¥¼ íŒë‹¨í•˜ì—¬ ëª©ë¡ì—ì„œ ì œê±°í•©ë‹ˆë‹¤.

```cpp
// Obstacle í´ë˜ìŠ¤ Update, Draw, IsOffScreen í•¨ìˆ˜ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void Obstacle::Update(float deltaTime) {
    // ìƒë‹¨ì—ì„œ í•˜ë‹¨ìœ¼ë¡œ ì´ë™
    position.y += speed * deltaTime;
}

void Obstacle::Draw() {
    // ì‚¬ê°í˜• í˜•íƒœì˜ ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
    DrawRectangleV(position, size, color);
}

bool Obstacle::IsOffScreen(int screenHeight) {
    // ê°ì²´ê°€ í™”ë©´ í•˜ë‹¨ ë°–ìœ¼ë¡œ ì™„ì „íˆ ë‚˜ê°”ëŠ”ì§€ ì²´í¬
    return position.y > screenHeight; // ê°ì²´ì˜ ì¢Œìƒë‹¨ y ì¢Œí‘œê°€ í™”ë©´ ë†’ì´ë¥¼ ë„˜ì—ˆëŠ”ì§€ ì²´í¬
    // ë˜ëŠ” return position.y + size.y > screenHeight; // ê°ì²´ì˜ í•˜ë‹¨ y ì¢Œí‘œê°€ í™”ë©´ ë†’ì´ë¥¼ ë„˜ì—ˆëŠ”ì§€ ì²´í¬
}

// LifeItem í´ë˜ìŠ¤ë„ ìœ ì‚¬í•˜ê²Œ êµ¬í˜„ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void LifeItem::Update(float deltaTime) {
    position.y += speed * deltaTime;
}

void LifeItem::Draw() {
    DrawRectangleV(position, size, color);
}

bool LifeItem::IsOffScreen(int screenHeight) {
    return position.y > screenHeight;
}
```

`GameManager::UpdateGame()` ë‚´ì—ì„œ `timeSinceLastObstacle` ë° `timeSinceLastLifeItem` íƒ€ì´ë¨¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¼ì • ê°„ê²©ë§ˆë‹¤ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  `obstacles` ë° `lifeItems` ë²¡í„°ì— ì¶”ê°€í•˜ëŠ” ë¡œì§ì´ í¬í•¨ë©ë‹ˆë‹¤. ìƒì„± ë¹ˆë„ëŠ” ìŠ¤í…Œì´ì§€ì— ë”°ë¼ ì¡°ì ˆë©ë‹ˆë‹¤. í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ê°ì²´ëŠ” `std::remove_if`ì™€ `erase`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª©ë¡ì—ì„œ ì œê±°í•©ë‹ˆë‹¤.

### 4\. ì¶©ëŒ ê°ì§€, ìƒëª… ê°ì†Œ ë° ìƒëª… íšŒë³µ

`GameManager::CheckCollisions()` í•¨ìˆ˜ì—ì„œ í”Œë ˆì´ì–´ì™€ ì¥ì• ë¬¼/ìƒëª… ë°•ìŠ¤ ê°„ì˜ ì¶©ëŒì„ `CheckCollisionRecs()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°ì§€í•˜ê³ , ì¶©ëŒ ê²°ê³¼ì— ë”°ë¼ í”Œë ˆì´ì–´ì˜ ìƒëª…ì„ ì¦ê°ì‹œí‚¤ê³  ì¶©ëŒí•œ ê°ì²´ë¥¼ ëª©ë¡ì—ì„œ ì œê±°í•©ë‹ˆë‹¤.

```cpp
// GameManager CheckCollisions í•¨ìˆ˜ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void GameManager::CheckCollisions() {
    // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” ì¶©ëŒ ì²´í¬ë¥¼ í•˜ì§€ ì•ŠìŒ
    if (gameState != GAME_PLAYING) return;

    // ì£¼ì¸ê³µì˜ ì¶©ëŒ ì˜ì—­ (ì‚¬ê°í˜•)
    Rectangle playerRect = { player.position.x, player.position.y, player.size.x, player.size.y };

    // --- ì¥ì• ë¬¼ê³¼ì˜ ì¶©ëŒ ì²´í¬ (ìƒëª… ê°ì†Œ) ---
    // ì¥ì• ë¬¼ ëª©ë¡ì„ ìˆœíšŒí•˜ë©° ì¶©ëŒ ì²´í¬ ë° ì œê±°
    obstacles.erase(std::remove_if(obstacles.begin(), obstacles.end(), [&](const Obstacle& obs){
        Rectangle obstacleRect = { obs.position.x, obs.position.y, obs.size.x, obs.size.y };
        bool collided = CheckCollisionRecs(playerRect, obstacleRect);

        if (collided) {
            // TODO: í”Œë ˆì´ì–´ ë¬´ì  ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ìƒëª… ê°ì†Œ
            // if (!player.isInvincible) {
                player.lives--; // Player í´ë˜ìŠ¤ì— lives ë©¤ë²„ê°€ ìˆë‹¤ê³  ê°€ì •
                TraceLog(LOG_INFO, TextFormat("Hit Obstacle! Lives: %i", player.lives));
                // TODO: í”Œë ˆì´ì–´ì—ê²Œ ì§§ì€ ë¬´ì  ì‹œê°„ ë¶€ì—¬ (ë¬´ì  íƒ€ì´ë¨¸ ì‹œì‘ ë“±)
                return true; // ì¶©ëŒí•œ ì¥ì• ë¬¼ ì œê±°
            // }
        }
        return obs.IsOffScreen(screenHeight); // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì¥ì• ë¬¼ ì œê±°
    }), obstacles.end());


    // --- ìƒëª… íšŒë³µ ì•„ì´í…œê³¼ì˜ ì¶©ëŒ ì²´í¬ (ìƒëª… ì¦ê°€) ---
    // ìƒëª… íšŒë³µ ì•„ì´í…œ ëª©ë¡ì„ ìˆœíšŒí•˜ë©° ì¶©ëŒ ì²´í¬ ë° ì œê±°
    lifeItems.erase(std::remove_if(lifeItems.begin(), lifeItems.end(), [&](const LifeItem& item){
         Rectangle lifeItemRect = { item.position.x, item.position.y, item.size.x, item.size.y };
         bool collided = CheckCollisionRecs(playerRect, lifeItemRect);

        if (collided) {
            // ì¶©ëŒ ë°œìƒ ì‹œ ìƒëª… ì¦ê°€ (ìµœëŒ€ ìƒëª… ì œí•œ)
            player.lives++; // ìƒëª… ì¦ê°€
             if (player.lives > player.maxLives) {
                player.lives = player.maxLives; // ìµœëŒ€ ìƒëª…ìœ¼ë¡œ ì œí•œ
            }
            TraceLog(LOG_INFO, TextFormat("Got Life Item! Lives: %i", player.lives));
            return true; // ì¶©ëŒí•œ ì•„ì´í…œ ì œê±°
        }
        return item.IsOffScreen(screenHeight); // í™”ë©´ ë°– ì•„ì´í…œ ì œê±°
    }), lifeItems.end());

    // ëª¨ë“  ì¶©ëŒ ì²´í¬ ë° ìƒëª… ìƒíƒœ í™•ì¸ í›„ ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì „í™˜
    if (player.lives <= 0) {
        gameState = GAME_OVER;
        finalScore = score; // ê²Œì„ ì˜¤ë²„ ì‹œ ìµœì¢… ì ìˆ˜ ì €ì¥
        TraceLog(LOG_INFO, TextFormat("Game Over! Final Score: %i", finalScore));
        // TODO: ê²Œì„ ì˜¤ë²„ ìƒíƒœë¡œ ì „í™˜ ì‹œ í•„ìš”í•œ ì¶”ê°€ ì‘ì—… (ì˜ˆ: íƒ€ì´ë¨¸ ì¤‘ì§€)
    }
}
```

### 5\. ì ìˆ˜ ë° ì‹œê°„ ì‹œìŠ¤í…œ

`GameManager::UpdateGame`ì—ì„œ `elapsedTime`ì„ ëˆ„ì í•˜ê³ , `lastScoreTime`ê³¼ì˜ ì°¨ì´ë¥¼ ì´ìš©í•´ 1ì´ˆë§ˆë‹¤ ì ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤. `GameManager::DrawGame`ì—ì„œ í˜„ì¬ ì ìˆ˜ì™€ ê²½ê³¼ ì‹œê°„ì„ í™”ë©´ì— í‘œì‹œí•©ë‹ˆë‹¤.

```cpp
// GameManager UpdateGame í•¨ìˆ˜ ë‚´ ì ìˆ˜ ë° ì‹œê°„ ê´€ë ¨ ë¡œì§ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void GameManager::UpdateGame(float deltaTime) {
    if (gameState == GAME_PLAYING) {
        elapsedTime += deltaTime; // ê²½ê³¼ ì‹œê°„ ëˆ„ì 

        // 1ì´ˆë§ˆë‹¤ ì ìˆ˜ íšë“
        if (elapsedTime - lastScoreTime >= 1.0f) { // 1ì´ˆ ê°„ê²©ìœ¼ë¡œ ì²´í¬
            score++;
            lastScoreTime = elapsedTime; // ë§ˆì§€ë§‰ ì ìˆ˜ íšë“ ì‹œê°„ ì—…ë°ì´íŠ¸

            // ìŠ¤í…Œì´ì§€ ì¦ê°€ ì¡°ê±´ ì²´í¬ ë° ì²˜ë¦¬
            CheckStageIncrease();
        }
        // ... (ë‹¤ë¥¸ ì—…ë°ì´íŠ¸ ë¡œì§: í”Œë ˆì´ì–´, ì¥ì• ë¬¼, ì•„ì´í…œ ì—…ë°ì´íŠ¸ ë° ìƒì„±)
    }
    // ... (ê²Œì„ ì˜¤ë²„ ìƒíƒœ ì²˜ë¦¬)
}

// GameManager DrawGame í•¨ìˆ˜ ë‚´ ì ìˆ˜ ë° ì‹œê°„ í‘œì‹œ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void GameManager::DrawGame() {
    BeginDrawing();
    ClearBackground(RAYWHITE);

    if (gameState == GAME_PLAYING) {
        // ... (í”Œë ˆì´ì–´, ì¥ì• ë¬¼, ì•„ì´í…œ ê·¸ë¦¬ê¸°)

        // UI í‘œì‹œ
        DrawText(TextFormat("Score: %i", score), 10, 10, 20, BLACK);
        DrawText(TextFormat("Lives: %i", player.lives), 10, 30, 20, BLACK);
        DrawText(TextFormat("Time: %.0f", elapsedTime), 10, 50, 20, BLACK); // ì´ˆ ë‹¨ìœ„ ì •ìˆ˜ë¡œ í‘œì‹œ
        DrawText(TextFormat("Stage: %i", currentStage), screenWidth - 100, 10, 20, BLACK);

    }
    // ... (ê²Œì„ ì˜¤ë²„ í™”ë©´ ê·¸ë¦¬ê¸°)
    EndDrawing();
}
```

### 6\. ìŠ¤í…Œì´ì§€ ì‹œìŠ¤í…œ ë° ë‚œì´ë„ ì¡°ì ˆ

`GameManager` í´ë˜ìŠ¤ ë©¤ë²„ë¡œ í˜„ì¬ ìŠ¤í…Œì´ì§€, ìŠ¤í…Œì´ì§€ì—…ì— í•„ìš”í•œ ì ìˆ˜, ì†ë„/ìƒì„± ë¹ˆë„ ì¦ê°€ëŸ‰ ë“±ì„ ì •ì˜í•©ë‹ˆë‹¤. `GameManager::CheckStageIncrease()` í•¨ìˆ˜ë¥¼ í†µí•´ ì ìˆ˜ê°€ ì¼ì • ê¸°ì¤€ì— ë„ë‹¬í•˜ë©´ ìŠ¤í…Œì´ì§€ë¥¼ ì¦ê°€ì‹œí‚¤ê³ , ì¥ì• ë¬¼ ì†ë„ ë“±ì„ ì¡°ì ˆí•©ë‹ˆë‹¤. ì´ ë³€ê²½ëœ ê°’ì€ ì¥ì• ë¬¼ ìƒì„± ë¡œì§ì— ë°˜ì˜ë©ë‹ˆë‹¤.

```cpp
// GameManager í´ë˜ìŠ¤ ë©¤ë²„ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
// int currentStage = 1;
// int scorePerStage = 10; // ìŠ¤í…Œì´ì§€ê°€ ì¦ê°€í•˜ëŠ” ë° í•„ìš”í•œ ì ìˆ˜
// float baseObstacleSpeed = 200.0f; // ê¸°ë³¸ ì¥ì• ë¬¼ ì†ë„
// float speedIncreasePerStage = 50.0f; // ìŠ¤í…Œì´ì§€ë‹¹ ì¦ê°€ ì†ë„
// float baseSpawnRate = 2.0f; // ê¸°ë³¸ ìƒì„± ê°„ê²© (ì´ˆ)
// float spawnRateDecreasePerStage = 0.2f; // ìŠ¤í…Œì´ì§€ë‹¹ ìƒì„± ê°„ê²© ê°ì†ŒëŸ‰

// GameManager CheckStageIncrease í•¨ìˆ˜ (UpdateGameì—ì„œ ì ìˆ˜ íšë“ ì‹œ í˜¸ì¶œ - ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void GameManager::CheckStageIncrease() {
    // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì— í•„ìš”í•œ ì ìˆ˜ ê³„ì‚°
    int requiredScoreForNextStage = currentStage * scorePerStage;

    if (score >= requiredScoreForNextStage) {
        currentStage++;
        TraceLog(LOG_INFO, TextFormat("Stage Increased! Current Stage: %i", currentStage));

        // ìŠ¤í…Œì´ì§€ ì¦ê°€ì— ë”°ë¥¸ ì†ë„ ì¦ê°€
        float newObstacleSpeed = baseObstacleSpeed + (currentStage - 1) * speedIncreasePerStage;
        // í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¥ì• ë¬¼ë“¤ì˜ ì†ë„ë„ ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
         for (auto& obs : obstacles) { obs.speed = newObstacleSpeed; }

        // ìŠ¤í…Œì´ì§€ ì¦ê°€ì— ë”°ë¥¸ ìƒì„± ë¹ˆë„ ì¦ê°€ (ìƒì„± ê°„ê²© ê°ì†Œ)ëŠ” UpdateGameì—ì„œ timeSinceLastObstacle ë¡œì§ì— ì˜í•´ ìë™ ì ìš©ë¨
        // float newSpawnRate = baseSpawnRate - (currentStage - 1) * spawnRateDecreasePerStage;
        // if (newSpawnRate < 0.5f) newSpawnRate = 0.5f; // ìµœì†Œ ìƒì„± ê°„ê²© ì œí•œ (ì˜ˆ: 0.5ì´ˆ)
        // ì¥ì• ë¬¼ ìƒì„± ë¡œì§ì—ì„œ ì´ newSpawnRate ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
    }
}

// GameManagerì—ì„œ ì¥ì• ë¬¼ ìƒì„± ë¡œì§ ì¼ë¶€ (UpdateGame í•¨ìˆ˜ ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
// timeSinceLastObstacle += deltaTime;
// float currentSpawnRate = baseSpawnRate - (currentStage - 1) * spawnRateDecreasePerStage;
// if (currentSpawnRate < 0.5f) currentSpawnRate = 0.5f;
// if (timeSinceLastObstacle >= currentSpawnRate) {
//     // ìƒˆë¡œìš´ ì¥ì• ë¬¼ ìƒì„± ë¡œì§...
//     newObstacle.speed = baseObstacleSpeed + (currentStage - 1) * speedIncreasePerStage; // í˜„ì¬ ìŠ¤í…Œì´ì§€ ì†ë„ ì ìš©
//     // ...
// }
```

### 7\. ê²Œì„ ì˜¤ë²„ ë° ì¬ì‹œì‘/ì¢…ë£Œ

í”Œë ˆì´ì–´ì˜ ìƒëª…ì´ 0 ì´í•˜ê°€ ë˜ë©´ `GameManager::CheckCollisions()` í•¨ìˆ˜ì—ì„œ `gameState`ë¥¼ `GAME_OVER`ë¡œ ë³€ê²½í•©ë‹ˆë‹¤. `GameManager::DrawGame()` í•¨ìˆ˜ì—ì„œ ê²Œì„ ì˜¤ë²„ ìƒíƒœì¼ ë•Œ ê²Œì„ ì˜¤ë²„ ë©”ì‹œì§€ì™€ ìµœì¢… ì ìˆ˜, ì¬ì‹œì‘/ì¢…ë£Œ ì•ˆë‚´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤. `GameManager::HandleInput()` í•¨ìˆ˜ì—ì„œ ê²Œì„ ì˜¤ë²„ ìƒíƒœì¼ ë•Œ Space í‚¤ ì…ë ¥ì„ ê°ì§€í•˜ì—¬ `GameManager::InitGame()`ì„ í˜¸ì¶œí•˜ì—¬ ê²Œì„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ëª¨ë“  ìƒíƒœì—ì„œ Esc í‚¤ë¥¼ ëˆ„ë¥´ë©´ `shouldClose` í”Œë˜ê·¸ë¥¼ trueë¡œ ì„¤ì •í•˜ì—¬ ë©”ì¸ ë£¨í”„ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.

```cpp
// GameManager::HandleInput í•¨ìˆ˜ (ì „ì²´ ê²Œì„ ìƒíƒœì— ëŒ€í•œ ì…ë ¥ ì²˜ë¦¬ - ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)

void GameManager::HandleInput() {
    // Esc í‚¤ëŠ” ì–´ë–¤ ìƒíƒœì—ì„œë“  ê²Œì„ ì¢…ë£Œ
    if (IsKeyPressed(KEY_ESCAPE)) {
        shouldClose = true; // ë©”ì¸ ë£¨í”„ ì¢…ë£Œë¥¼ ì•Œë¦¬ëŠ” í”Œë˜ê·¸ (GameManager ë©¤ë²„)
    }

    if (gameState == GAME_PLAYING) {
        // í”Œë ˆì´ ì¤‘ ìƒíƒœì—ì„œì˜ ì…ë ¥ (í”Œë ˆì´ì–´ ì´ë™)
        // í”Œë ˆì´ì–´ í´ë˜ìŠ¤ì˜ HandleInput í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ì§ì ‘ ì²˜ë¦¬
        if (IsKeyDown(KEY_RIGHT)) player.position.x += player.speed * GetFrameTime();
        if (IsKeyDown(KEY_LEFT)) player.position.x -= player.speed * GetFrameTime();

        // í™”ë©´ ê²½ê³„ ì²´í¬ (Updateì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ì§€ë§Œ ì…ë ¥ê³¼ í•¨ê»˜ ì²˜ë¦¬ ê°€ëŠ¥)
        if (player.position.x < 0) player.position.x = 0;
        if (player.position.x > screenWidth - player.size.x) player.position.x = screenWidth - player.size.x;

    } else if (gameState == GAME_OVER) {
        // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œì˜ ì…ë ¥ (ì¬ì‹œì‘)
        if (IsKeyPressed(KEY_SPACE)) {
            InitGame(screenWidth, screenHeight); // ê²Œì„ ì¬ì‹œì‘
        }
    }
}

// GameManager::DrawGame í•¨ìˆ˜ ë‚´ ê²Œì„ ì˜¤ë²„ í™”ë©´ ì¶œë ¥ ë¡œì§ (ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
void GameManager::DrawGame() {
    BeginDrawing();
    ClearBackground(RAYWHITE);

    if (gameState == GAME_PLAYING) {
        // ... (í”Œë ˆì´ ì¤‘ UI ë° ê°ì²´ ê·¸ë¦¬ê¸°)
    } else if (gameState == GAME_OVER) {
        const char* gameOverText = "Game Over!";
        DrawText(gameOverText, screenWidth/2 - MeasureText(gameOverText, 40)/2, screenHeight/2 - 40, 40, RED); // í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì¡°ì •
        DrawText(TextFormat("Final Score: %i", finalScore), screenWidth/2 - MeasureText(TextFormat("Final Score: %i", finalScore), 30)/2, screenHeight/2 + 0, 30, BLACK); // í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì •
        DrawText("Press SPACE to Restart", screenWidth/2 - MeasureText("Press SPACE to Restart", 20)/2, screenHeight/2 + 40, 20, DARKGRAY);
        DrawText("Press ESC to Exit", screenWidth/2 - MeasureText("Press ESC to Exit", 20)/2, screenHeight/2 + 60, 20, DARKGRAY);
    }

    EndDrawing();
}

// GameManager::ShouldClose í•¨ìˆ˜ (ë©”ì¸ ë£¨í”„ ì¢…ë£Œ ì¡°ê±´ - ìœ„ main.cpp ë‚´ì— í¬í•¨ë˜ì–´ ìˆìŒ)
// bool GameManager::ShouldClose() const { return shouldClose || WindowShouldClose(); }
```

-----

## ğŸ’¬ í”„ë¡œì íŠ¸ ì†Œê°

### ğŸ”¹ ì „ì¬ë¯¼ (í”„ë¡œì íŠ¸ ê´€ë¦¬ / ê¸°íš ë° ì„¤ê³„)

> (ì‘ì„± ì˜ˆì •)

### ğŸ”¹ ê¹€ë¬´ì§„ (ê°œë°œ)

> (ì‘ì„± ì˜ˆì •)

### ğŸ”¹ ê¹€ì¤€ìš© (ë¬¸ì„œ / í…ŒìŠ¤íŠ¸)

> (ì‘ì„± ì˜ˆì •)

-----

```
```
